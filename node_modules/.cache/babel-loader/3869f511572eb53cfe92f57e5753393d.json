{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport { ref, isRef, nextTick } from 'vue';\nimport { isClient } from '@vueuse/core';\nimport '../../../utils/index2.mjs';\nimport { parseHeight } from './util2.mjs';\nimport { hasOwn } from '@vue/shared';\nclass TableLayout {\n  constructor(options) {\n    this.observers = [];\n    this.table = null;\n    this.store = null;\n    this.columns = [];\n    this.fit = true;\n    this.showHeader = true;\n    this.height = ref(null);\n    this.scrollX = ref(false);\n    this.scrollY = ref(false);\n    this.bodyWidth = ref(null);\n    this.fixedWidth = ref(null);\n    this.rightFixedWidth = ref(null);\n    this.tableHeight = ref(null);\n    this.headerHeight = ref(44);\n    this.appendHeight = ref(0);\n    this.footerHeight = ref(44);\n    this.viewportHeight = ref(null);\n    this.bodyHeight = ref(null);\n    this.bodyScrollHeight = ref(0);\n    this.fixedBodyHeight = ref(null);\n    this.gutterWidth = 0;\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        if (isRef(this[name])) {\n          this[name].value = options[name];\n        } else {\n          this[name] = options[name];\n        }\n      }\n    }\n    if (!this.table) {\n      throw new Error(\"Table is required for Table Layout\");\n    }\n    if (!this.store) {\n      throw new Error(\"Store is required for Table Layout\");\n    }\n  }\n  updateScrollY() {\n    const height = this.height.value;\n    if (height === null) return false;\n    const bodyWrapper = this.table.refs.bodyWrapper;\n    if (this.table.vnode.el && bodyWrapper) {\n      let scrollY = true;\n      const prevScrollY = this.scrollY.value;\n      if (this.bodyHeight.value === null) {\n        scrollY = false;\n      } else {\n        scrollY = bodyWrapper.scrollHeight > this.bodyHeight.value;\n      }\n      this.scrollY.value = scrollY;\n      return prevScrollY !== scrollY;\n    }\n    return false;\n  }\n  setHeight(value, prop = \"height\") {\n    if (!isClient) return;\n    const el = this.table.vnode.el;\n    value = parseHeight(value);\n    this.height.value = Number(value);\n    if (!el && (value || value === 0)) return nextTick(() => this.setHeight(value, prop));\n    if (typeof value === \"number\") {\n      el.style[prop] = `${value}px`;\n      this.updateElsHeight();\n    } else if (typeof value === \"string\") {\n      el.style[prop] = value;\n      this.updateElsHeight();\n    }\n  }\n  setMaxHeight(value) {\n    this.setHeight(value, \"max-height\");\n  }\n  getFlattenColumns() {\n    const flattenColumns = [];\n    const columns = this.table.store.states.columns.value;\n    columns.forEach(column => {\n      if (column.isColumnGroup) {\n        flattenColumns.push.apply(flattenColumns, column.columns);\n      } else {\n        flattenColumns.push(column);\n      }\n    });\n    return flattenColumns;\n  }\n  updateElsHeight() {\n    var _a, _b;\n    if (!this.table.$ready) return nextTick(() => this.updateElsHeight());\n    const {\n      tableWrapper,\n      headerWrapper,\n      appendWrapper,\n      footerWrapper,\n      tableHeader,\n      tableBody\n    } = this.table.refs;\n    if (tableWrapper && tableWrapper.style.display === \"none\") {\n      return;\n    }\n    const {\n      tableLayout\n    } = this.table.props;\n    this.appendHeight.value = appendWrapper ? appendWrapper.offsetHeight : 0;\n    if (this.showHeader && !headerWrapper && tableLayout === \"fixed\") {\n      return;\n    }\n    const headerTrElm = tableHeader ? tableHeader : null;\n    const noneHeader = this.headerDisplayNone(headerTrElm);\n    const headerWrapperOffsetHeight = (headerWrapper == null ? void 0 : headerWrapper.offsetHeight) || 0;\n    const headerHeight = this.headerHeight.value = !this.showHeader ? 0 : headerWrapperOffsetHeight;\n    if (this.showHeader && !noneHeader && headerWrapperOffsetHeight > 0 && (this.table.store.states.columns.value || []).length > 0 && headerHeight < 2) {\n      return nextTick(() => this.updateElsHeight());\n    }\n    const tableHeight = this.tableHeight.value = (_b = (_a = this.table) == null ? void 0 : _a.vnode.el) == null ? void 0 : _b.clientHeight;\n    const footerHeight = this.footerHeight.value = footerWrapper ? footerWrapper.offsetHeight : 0;\n    if (this.height.value !== null) {\n      if (this.bodyHeight.value === null) {\n        requestAnimationFrame(() => this.updateElsHeight());\n      }\n      this.bodyHeight.value = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);\n      this.bodyScrollHeight.value = tableBody == null ? void 0 : tableBody.scrollHeight;\n    }\n    this.fixedBodyHeight.value = this.scrollX.value ? this.bodyHeight.value - this.gutterWidth : this.bodyHeight.value;\n    this.viewportHeight.value = this.scrollX.value ? tableHeight - this.gutterWidth : tableHeight;\n    this.updateScrollY();\n    this.notifyObservers(\"scrollable\");\n  }\n  headerDisplayNone(elm) {\n    if (!elm) return true;\n    let headerChild = elm;\n    while (headerChild.tagName !== \"DIV\") {\n      if (getComputedStyle(headerChild).display === \"none\") {\n        return true;\n      }\n      headerChild = headerChild.parentElement;\n    }\n    return false;\n  }\n  updateColumnsWidth() {\n    if (!isClient) return;\n    const fit = this.fit;\n    const bodyWidth = this.table.vnode.el.clientWidth;\n    let bodyMinWidth = 0;\n    const flattenColumns = this.getFlattenColumns();\n    const flexColumns = flattenColumns.filter(column => typeof column.width !== \"number\");\n    flattenColumns.forEach(column => {\n      if (typeof column.width === \"number\" && column.realWidth) column.realWidth = null;\n    });\n    if (flexColumns.length > 0 && fit) {\n      flattenColumns.forEach(column => {\n        bodyMinWidth += Number(column.width || column.minWidth || 80);\n      });\n      if (bodyMinWidth <= bodyWidth) {\n        this.scrollX.value = false;\n        const totalFlexWidth = bodyWidth - bodyMinWidth;\n        if (flexColumns.length === 1) {\n          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth;\n        } else {\n          const allColumnsWidth = flexColumns.reduce((prev, column) => prev + Number(column.minWidth || 80), 0);\n          const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;\n          let noneFirstWidth = 0;\n          flexColumns.forEach((column, index) => {\n            if (index === 0) return;\n            const flexWidth = Math.floor(Number(column.minWidth || 80) * flexWidthPerPixel);\n            noneFirstWidth += flexWidth;\n            column.realWidth = Number(column.minWidth || 80) + flexWidth;\n          });\n          flexColumns[0].realWidth = Number(flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;\n        }\n      } else {\n        this.scrollX.value = true;\n        flexColumns.forEach(column => {\n          column.realWidth = Number(column.minWidth);\n        });\n      }\n      this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);\n      this.table.state.resizeState.value.width = this.bodyWidth.value;\n    } else {\n      flattenColumns.forEach(column => {\n        if (!column.width && !column.minWidth) {\n          column.realWidth = 80;\n        } else {\n          column.realWidth = Number(column.width || column.minWidth);\n        }\n        bodyMinWidth += column.realWidth;\n      });\n      this.scrollX.value = bodyMinWidth > bodyWidth;\n      this.bodyWidth.value = bodyMinWidth;\n    }\n    const fixedColumns = this.store.states.fixedColumns.value;\n    if (fixedColumns.length > 0) {\n      let fixedWidth = 0;\n      fixedColumns.forEach(column => {\n        fixedWidth += Number(column.realWidth || column.width);\n      });\n      this.fixedWidth.value = fixedWidth;\n    }\n    const rightFixedColumns = this.store.states.rightFixedColumns.value;\n    if (rightFixedColumns.length > 0) {\n      let rightFixedWidth = 0;\n      rightFixedColumns.forEach(column => {\n        rightFixedWidth += Number(column.realWidth || column.width);\n      });\n      this.rightFixedWidth.value = rightFixedWidth;\n    }\n    this.notifyObservers(\"columns\");\n  }\n  addObserver(observer) {\n    this.observers.push(observer);\n  }\n  removeObserver(observer) {\n    const index = this.observers.indexOf(observer);\n    if (index !== -1) {\n      this.observers.splice(index, 1);\n    }\n  }\n  notifyObservers(event) {\n    const observers = this.observers;\n    observers.forEach(observer => {\n      var _a, _b;\n      switch (event) {\n        case \"columns\":\n          (_a = observer.state) == null ? void 0 : _a.onColumnsChange(this);\n          break;\n        case \"scrollable\":\n          (_b = observer.state) == null ? void 0 : _b.onScrollableChange(this);\n          break;\n        default:\n          throw new Error(`Table Layout don't have event ${event}.`);\n      }\n    });\n  }\n}\nexport { TableLayout as default };","map":{"version":3,"mappings":";;;;;;AAIA,MAAMA,WAAW,CAAC;EAChBC,WAAWA,CAACC,OAAO,EAAE;IACnB,IAAI,CAACC,SAAS,GAAG,EAAE;IACnB,IAAI,CAACC,KAAK,GAAG,IAAI;IACjB,IAAI,CAACC,KAAK,GAAG,IAAI;IACjB,IAAI,CAACC,OAAO,GAAG,EAAE;IACjB,IAAI,CAACC,GAAG,GAAG,IAAI;IACf,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB,IAAI,CAACC,MAAM,GAAGC,GAAG,CAAC,IAAI,CAAC;IACvB,IAAI,CAACC,OAAO,GAAGD,GAAG,CAAC,KAAK,CAAC;IACzB,IAAI,CAACE,OAAO,GAAGF,GAAG,CAAC,KAAK,CAAC;IACzB,IAAI,CAACG,SAAS,GAAGH,GAAG,CAAC,IAAI,CAAC;IAC1B,IAAI,CAACI,UAAU,GAAGJ,GAAG,CAAC,IAAI,CAAC;IAC3B,IAAI,CAACK,eAAe,GAAGL,GAAG,CAAC,IAAI,CAAC;IAChC,IAAI,CAACM,WAAW,GAAGN,GAAG,CAAC,IAAI,CAAC;IAC5B,IAAI,CAACO,YAAY,GAAGP,GAAG,CAAC,EAAE,CAAC;IAC3B,IAAI,CAACQ,YAAY,GAAGR,GAAG,CAAC,CAAC,CAAC;IAC1B,IAAI,CAACS,YAAY,GAAGT,GAAG,CAAC,EAAE,CAAC;IAC3B,IAAI,CAACU,cAAc,GAAGV,GAAG,CAAC,IAAI,CAAC;IAC/B,IAAI,CAACW,UAAU,GAAGX,GAAG,CAAC,IAAI,CAAC;IAC3B,IAAI,CAACY,gBAAgB,GAAGZ,GAAG,CAAC,CAAC,CAAC;IAC9B,IAAI,CAACa,eAAe,GAAGb,GAAG,CAAC,IAAI,CAAC;IAChC,IAAI,CAACc,WAAW,GAAG,CAAC;IACpB,KAAK,MAAMC,IAAI,IAAIvB,OAAO,EAAE;MAC1B,IAAIwB,MAAM,CAACxB,OAAO,EAAEuB,IAAI,CAAC,EAAE;QACzB,IAAIE,KAAK,CAAC,IAAI,CAACF,IAAI,CAAC,CAAC,EAAE;UACrB,IAAI,CAACA,IAAI,CAAC,CAACG,KAAK,GAAG1B,OAAO,CAACuB,IAAI,CAAC;QAC1C,CAAS,MAAM;UACL,IAAI,CAACA,IAAI,CAAC,GAAGvB,OAAO,CAACuB,IAAI,CAAC;QACpC;MACA;IACA;IACI,IAAI,CAAC,IAAI,CAACrB,KAAK,EAAE;MACf,MAAM,IAAIyB,KAAK,CAAC,oCAAoC,CAAC;IAC3D;IACI,IAAI,CAAC,IAAI,CAACxB,KAAK,EAAE;MACf,MAAM,IAAIwB,KAAK,CAAC,oCAAoC,CAAC;IAC3D;EACA;EACEC,aAAaA,GAAG;IACd,MAAMrB,MAAM,GAAG,IAAI,CAACA,MAAM,CAACmB,KAAK;IAChC,IAAInB,MAAM,KAAK,IAAI,EACjB,OAAO,KAAK;IACd,MAAMsB,WAAW,GAAG,IAAI,CAAC3B,KAAK,CAAC4B,IAAI,CAACD,WAAW;IAC/C,IAAI,IAAI,CAAC3B,KAAK,CAAC6B,KAAK,CAACC,EAAE,IAAIH,WAAW,EAAE;MACtC,IAAInB,OAAO,GAAG,IAAI;MAClB,MAAMuB,WAAW,GAAG,IAAI,CAACvB,OAAO,CAACgB,KAAK;MACtC,IAAI,IAAI,CAACP,UAAU,CAACO,KAAK,KAAK,IAAI,EAAE;QAClChB,OAAO,GAAG,KAAK;MACvB,CAAO,MAAM;QACLA,OAAO,GAAGmB,WAAW,CAACK,YAAY,GAAG,IAAI,CAACf,UAAU,CAACO,KAAK;MAClE;MACM,IAAI,CAAChB,OAAO,CAACgB,KAAK,GAAGhB,OAAO;MAC5B,OAAOuB,WAAW,KAAKvB,OAAO;IACpC;IACI,OAAO,KAAK;EAChB;EACEyB,SAASA,CAACT,KAAK,EAAEU,IAAI,GAAG,QAAQ,EAAE;IAChC,IAAI,CAACC,QAAQ,EACX;IACF,MAAML,EAAE,GAAG,IAAI,CAAC9B,KAAK,CAAC6B,KAAK,CAACC,EAAE;IAC9BN,KAAK,GAAGY,WAAW,CAACZ,KAAK,CAAC;IAC1B,IAAI,CAACnB,MAAM,CAACmB,KAAK,GAAGa,MAAM,CAACb,KAAK,CAAC;IACjC,IAAI,CAACM,EAAE,KAAKN,KAAK,IAAIA,KAAK,KAAK,CAAC,CAAC,EAC/B,OAAOc,QAAQ,CAAC,MAAM,IAAI,CAACL,SAAS,CAACT,KAAK,EAAEU,IAAI,CAAC,CAAC;IACpD,IAAI,OAAOV,KAAK,KAAK,QAAQ,EAAE;MAC7BM,EAAE,CAACS,KAAK,CAACL,IAAI,CAAC,GAAI,GAAEV,KAAM,IAAG;MAC7B,IAAI,CAACgB,eAAe,EAAE;IAC5B,CAAK,MAAM,IAAI,OAAOhB,KAAK,KAAK,QAAQ,EAAE;MACpCM,EAAE,CAACS,KAAK,CAACL,IAAI,CAAC,GAAGV,KAAK;MACtB,IAAI,CAACgB,eAAe,EAAE;IAC5B;EACA;EACEC,YAAYA,CAACjB,KAAK,EAAE;IAClB,IAAI,CAACS,SAAS,CAACT,KAAK,EAAE,YAAY,CAAC;EACvC;EACEkB,iBAAiBA,GAAG;IAClB,MAAMC,cAAc,GAAG,EAAE;IACzB,MAAMzC,OAAO,GAAG,IAAI,CAACF,KAAK,CAACC,KAAK,CAAC2C,MAAM,CAAC1C,OAAO,CAACsB,KAAK;IACrDtB,OAAO,CAAC2C,OAAO,CAAEC,MAAM,IAAK;MAC1B,IAAIA,MAAM,CAACC,aAAa,EAAE;QACxBJ,cAAc,CAACK,IAAI,CAACC,KAAK,CAACN,cAAc,EAAEG,MAAM,CAAC5C,OAAO,CAAC;MACjE,CAAO,MAAM;QACLyC,cAAc,CAACK,IAAI,CAACF,MAAM,CAAC;MACnC;IACA,CAAK,CAAC;IACF,OAAOH,cAAc;EACzB;EACEH,eAAeA,GAAG;IAChB,IAAIU,EAAE,EAAEC,EAAE;IACV,IAAI,CAAC,IAAI,CAACnD,KAAK,CAACoD,MAAM,EACpB,OAAOd,QAAQ,CAAC,MAAM,IAAI,CAACE,eAAe,EAAE,CAAC;IAC/C,MAAM;MACJa,YAAY;MACZC,aAAa;MACbC,aAAa;MACbC,aAAa;MACbC,WAAW;MACXC;IACN,CAAK,GAAG,IAAI,CAAC1D,KAAK,CAAC4B,IAAI;IACnB,IAAIyB,YAAY,IAAIA,YAAY,CAACd,KAAK,CAACoB,OAAO,KAAK,MAAM,EAAE;MACzD;IACN;IACI,MAAM;MAAEC;IAAW,CAAE,GAAG,IAAI,CAAC5D,KAAK,CAAC6D,KAAK;IACxC,IAAI,CAAC/C,YAAY,CAACU,KAAK,GAAG+B,aAAa,GAAGA,aAAa,CAACO,YAAY,GAAG,CAAC;IACxE,IAAI,IAAI,CAAC1D,UAAU,IAAI,CAACkD,aAAa,IAAIM,WAAW,KAAK,OAAO,EAAE;MAChE;IACN;IACI,MAAMG,WAAW,GAAGN,WAAW,GAAGA,WAAW,GAAG,IAAI;IACpD,MAAMO,UAAU,GAAG,IAAI,CAACC,iBAAiB,CAACF,WAAW,CAAC;IACtD,MAAMG,yBAAyB,GAAG,CAACZ,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACQ,YAAY,KAAK,CAAC;IACpG,MAAMjD,YAAY,GAAG,IAAI,CAACA,YAAY,CAACW,KAAK,GAAG,CAAC,IAAI,CAACpB,UAAU,GAAG,CAAC,GAAG8D,yBAAyB;IAC/F,IAAI,IAAI,CAAC9D,UAAU,IAAI,CAAC4D,UAAU,IAAIE,yBAAyB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAClE,KAAK,CAACC,KAAK,CAAC2C,MAAM,CAAC1C,OAAO,CAACsB,KAAK,IAAI,EAAE,EAAE2C,MAAM,GAAG,CAAC,IAAItD,YAAY,GAAG,CAAC,EAAE;MACnJ,OAAOyB,QAAQ,CAAC,MAAM,IAAI,CAACE,eAAe,EAAE,CAAC;IACnD;IACI,MAAM5B,WAAW,GAAG,IAAI,CAACA,WAAW,CAACY,KAAK,GAAG,CAAC2B,EAAE,GAAG,CAACD,EAAE,GAAG,IAAI,CAAClD,KAAK,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGkD,EAAE,CAACrB,KAAK,CAACC,EAAE,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGqB,EAAE,CAACiB,YAAY;IACvI,MAAMrD,YAAY,GAAG,IAAI,CAACA,YAAY,CAACS,KAAK,GAAGgC,aAAa,GAAGA,aAAa,CAACM,YAAY,GAAG,CAAC;IAC7F,IAAI,IAAI,CAACzD,MAAM,CAACmB,KAAK,KAAK,IAAI,EAAE;MAC9B,IAAI,IAAI,CAACP,UAAU,CAACO,KAAK,KAAK,IAAI,EAAE;QAClC6C,qBAAqB,CAAC,MAAM,IAAI,CAAC7B,eAAe,EAAE,CAAC;MAC3D;MACM,IAAI,CAACvB,UAAU,CAACO,KAAK,GAAGZ,WAAW,GAAGC,YAAY,GAAGE,YAAY,IAAIyC,aAAa,GAAG,CAAC,GAAG,CAAC,CAAC;MAC3F,IAAI,CAACtC,gBAAgB,CAACM,KAAK,GAAGkC,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAAC1B,YAAY;IACvF;IACI,IAAI,CAACb,eAAe,CAACK,KAAK,GAAG,IAAI,CAACjB,OAAO,CAACiB,KAAK,GAAG,IAAI,CAACP,UAAU,CAACO,KAAK,GAAG,IAAI,CAACJ,WAAW,GAAG,IAAI,CAACH,UAAU,CAACO,KAAK;IAClH,IAAI,CAACR,cAAc,CAACQ,KAAK,GAAG,IAAI,CAACjB,OAAO,CAACiB,KAAK,GAAGZ,WAAW,GAAG,IAAI,CAACQ,WAAW,GAAGR,WAAW;IAC7F,IAAI,CAACc,aAAa,EAAE;IACpB,IAAI,CAAC4C,eAAe,CAAC,YAAY,CAAC;EACtC;EACEL,iBAAiBA,CAACM,GAAG,EAAE;IACrB,IAAI,CAACA,GAAG,EACN,OAAO,IAAI;IACb,IAAIC,WAAW,GAAGD,GAAG;IACrB,OAAOC,WAAW,CAACC,OAAO,KAAK,KAAK,EAAE;MACpC,IAAIC,gBAAgB,CAACF,WAAW,CAAC,CAACb,OAAO,KAAK,MAAM,EAAE;QACpD,OAAO,IAAI;MACnB;MACMa,WAAW,GAAGA,WAAW,CAACG,aAAa;IAC7C;IACI,OAAO,KAAK;EAChB;EACEC,kBAAkBA,GAAG;IACnB,IAAI,CAACzC,QAAQ,EACX;IACF,MAAMhC,GAAG,GAAG,IAAI,CAACA,GAAG;IACpB,MAAMM,SAAS,GAAG,IAAI,CAACT,KAAK,CAAC6B,KAAK,CAACC,EAAE,CAAC+C,WAAW;IACjD,IAAIC,YAAY,GAAG,CAAC;IACpB,MAAMnC,cAAc,GAAG,IAAI,CAACD,iBAAiB,EAAE;IAC/C,MAAMqC,WAAW,GAAGpC,cAAc,CAACqC,MAAM,CAAElC,MAAM,IAAK,OAAOA,MAAM,CAACmC,KAAK,KAAK,QAAQ,CAAC;IACvFtC,cAAc,CAACE,OAAO,CAAEC,MAAM,IAAK;MACjC,IAAI,OAAOA,MAAM,CAACmC,KAAK,KAAK,QAAQ,IAAInC,MAAM,CAACoC,SAAS,EACtDpC,MAAM,CAACoC,SAAS,GAAG,IAAI;IAC/B,CAAK,CAAC;IACF,IAAIH,WAAW,CAACZ,MAAM,GAAG,CAAC,IAAIhE,GAAG,EAAE;MACjCwC,cAAc,CAACE,OAAO,CAAEC,MAAM,IAAK;QACjCgC,YAAY,IAAIzC,MAAM,CAACS,MAAM,CAACmC,KAAK,IAAInC,MAAM,CAACqC,QAAQ,IAAI,EAAE,CAAC;MACrE,CAAO,CAAC;MACF,IAAIL,YAAY,IAAIrE,SAAS,EAAE;QAC7B,IAAI,CAACF,OAAO,CAACiB,KAAK,GAAG,KAAK;QAC1B,MAAM4D,cAAc,GAAG3E,SAAS,GAAGqE,YAAY;QAC/C,IAAIC,WAAW,CAACZ,MAAM,KAAK,CAAC,EAAE;UAC5BY,WAAW,CAAC,CAAC,CAAC,CAACG,SAAS,GAAG7C,MAAM,CAAC0C,WAAW,CAAC,CAAC,CAAC,CAACI,QAAQ,IAAI,EAAE,CAAC,GAAGC,cAAc;QAC3F,CAAS,MAAM;UACL,MAAMC,eAAe,GAAGN,WAAW,CAACO,MAAM,CAAC,CAACC,IAAI,EAAEzC,MAAM,KAAKyC,IAAI,GAAGlD,MAAM,CAACS,MAAM,CAACqC,QAAQ,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;UACrG,MAAMK,iBAAiB,GAAGJ,cAAc,GAAGC,eAAe;UAC1D,IAAII,cAAc,GAAG,CAAC;UACtBV,WAAW,CAAClC,OAAO,CAAC,CAACC,MAAM,EAAE4C,KAAK,KAAK;YACrC,IAAIA,KAAK,KAAK,CAAC,EACb;YACF,MAAMC,SAAS,GAAGC,IAAI,CAACC,KAAK,CAACxD,MAAM,CAACS,MAAM,CAACqC,QAAQ,IAAI,EAAE,CAAC,GAAGK,iBAAiB,CAAC;YAC/EC,cAAc,IAAIE,SAAS;YAC3B7C,MAAM,CAACoC,SAAS,GAAG7C,MAAM,CAACS,MAAM,CAACqC,QAAQ,IAAI,EAAE,CAAC,GAAGQ,SAAS;UACxE,CAAW,CAAC;UACFZ,WAAW,CAAC,CAAC,CAAC,CAACG,SAAS,GAAG7C,MAAM,CAAC0C,WAAW,CAAC,CAAC,CAAC,CAACI,QAAQ,IAAI,EAAE,CAAC,GAAGC,cAAc,GAAGK,cAAc;QAC5G;MACA,CAAO,MAAM;QACL,IAAI,CAAClF,OAAO,CAACiB,KAAK,GAAG,IAAI;QACzBuD,WAAW,CAAClC,OAAO,CAAEC,MAAM,IAAK;UAC9BA,MAAM,CAACoC,SAAS,GAAG7C,MAAM,CAACS,MAAM,CAACqC,QAAQ,CAAC;QACpD,CAAS,CAAC;MACV;MACM,IAAI,CAAC1E,SAAS,CAACe,KAAK,GAAGoE,IAAI,CAACE,GAAG,CAAChB,YAAY,EAAErE,SAAS,CAAC;MACxD,IAAI,CAACT,KAAK,CAAC+F,KAAK,CAACC,WAAW,CAACxE,KAAK,CAACyD,KAAK,GAAG,IAAI,CAACxE,SAAS,CAACe,KAAK;IACrE,CAAK,MAAM;MACLmB,cAAc,CAACE,OAAO,CAAEC,MAAM,IAAK;QACjC,IAAI,CAACA,MAAM,CAACmC,KAAK,IAAI,CAACnC,MAAM,CAACqC,QAAQ,EAAE;UACrCrC,MAAM,CAACoC,SAAS,GAAG,EAAE;QAC/B,CAAS,MAAM;UACLpC,MAAM,CAACoC,SAAS,GAAG7C,MAAM,CAACS,MAAM,CAACmC,KAAK,IAAInC,MAAM,CAACqC,QAAQ,CAAC;QACpE;QACQL,YAAY,IAAIhC,MAAM,CAACoC,SAAS;MACxC,CAAO,CAAC;MACF,IAAI,CAAC3E,OAAO,CAACiB,KAAK,GAAGsD,YAAY,GAAGrE,SAAS;MAC7C,IAAI,CAACA,SAAS,CAACe,KAAK,GAAGsD,YAAY;IACzC;IACI,MAAMmB,YAAY,GAAG,IAAI,CAAChG,KAAK,CAAC2C,MAAM,CAACqD,YAAY,CAACzE,KAAK;IACzD,IAAIyE,YAAY,CAAC9B,MAAM,GAAG,CAAC,EAAE;MAC3B,IAAIzD,UAAU,GAAG,CAAC;MAClBuF,YAAY,CAACpD,OAAO,CAAEC,MAAM,IAAK;QAC/BpC,UAAU,IAAI2B,MAAM,CAACS,MAAM,CAACoC,SAAS,IAAIpC,MAAM,CAACmC,KAAK,CAAC;MAC9D,CAAO,CAAC;MACF,IAAI,CAACvE,UAAU,CAACc,KAAK,GAAGd,UAAU;IACxC;IACI,MAAMwF,iBAAiB,GAAG,IAAI,CAACjG,KAAK,CAAC2C,MAAM,CAACsD,iBAAiB,CAAC1E,KAAK;IACnE,IAAI0E,iBAAiB,CAAC/B,MAAM,GAAG,CAAC,EAAE;MAChC,IAAIxD,eAAe,GAAG,CAAC;MACvBuF,iBAAiB,CAACrD,OAAO,CAAEC,MAAM,IAAK;QACpCnC,eAAe,IAAI0B,MAAM,CAACS,MAAM,CAACoC,SAAS,IAAIpC,MAAM,CAACmC,KAAK,CAAC;MACnE,CAAO,CAAC;MACF,IAAI,CAACtE,eAAe,CAACa,KAAK,GAAGb,eAAe;IAClD;IACI,IAAI,CAAC2D,eAAe,CAAC,SAAS,CAAC;EACnC;EACE6B,WAAWA,CAACC,QAAQ,EAAE;IACpB,IAAI,CAACrG,SAAS,CAACiD,IAAI,CAACoD,QAAQ,CAAC;EACjC;EACEC,cAAcA,CAACD,QAAQ,EAAE;IACvB,MAAMV,KAAK,GAAG,IAAI,CAAC3F,SAAS,CAACuG,OAAO,CAACF,QAAQ,CAAC;IAC9C,IAAIV,KAAK,KAAK,CAAC,CAAC,EAAE;MAChB,IAAI,CAAC3F,SAAS,CAACwG,MAAM,CAACb,KAAK,EAAE,CAAC,CAAC;IACrC;EACA;EACEpB,eAAeA,CAACkC,KAAK,EAAE;IACrB,MAAMzG,SAAS,GAAG,IAAI,CAACA,SAAS;IAChCA,SAAS,CAAC8C,OAAO,CAAEuD,QAAQ,IAAK;MAC9B,IAAIlD,EAAE,EAAEC,EAAE;MACV,QAAQqD,KAAK;QACX,KAAK,SAAS;UACZ,CAACtD,EAAE,GAAGkD,QAAQ,CAACL,KAAK,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG7C,EAAE,CAACuD,eAAe,CAAC,IAAI,CAAC;UACjE;QACF,KAAK,YAAY;UACf,CAACtD,EAAE,GAAGiD,QAAQ,CAACL,KAAK,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG5C,EAAE,CAACuD,kBAAkB,CAAC,IAAI,CAAC;UACpE;QACF;UACE,MAAM,IAAIjF,KAAK,CAAE,iCAAgC+E,KAAM,GAAE,CAAC;MACpE;IACA,CAAK,CAAC;EACN;AACA","names":["TableLayout","constructor","options","observers","table","store","columns","fit","showHeader","height","ref","scrollX","scrollY","bodyWidth","fixedWidth","rightFixedWidth","tableHeight","headerHeight","appendHeight","footerHeight","viewportHeight","bodyHeight","bodyScrollHeight","fixedBodyHeight","gutterWidth","name","hasOwn","isRef","value","Error","updateScrollY","bodyWrapper","refs","vnode","el","prevScrollY","scrollHeight","setHeight","prop","isClient","parseHeight","Number","nextTick","style","updateElsHeight","setMaxHeight","getFlattenColumns","flattenColumns","states","forEach","column","isColumnGroup","push","apply","_a","_b","$ready","tableWrapper","headerWrapper","appendWrapper","footerWrapper","tableHeader","tableBody","display","tableLayout","props","offsetHeight","headerTrElm","noneHeader","headerDisplayNone","headerWrapperOffsetHeight","length","clientHeight","requestAnimationFrame","notifyObservers","elm","headerChild","tagName","getComputedStyle","parentElement","updateColumnsWidth","clientWidth","bodyMinWidth","flexColumns","filter","width","realWidth","minWidth","totalFlexWidth","allColumnsWidth","reduce","prev","flexWidthPerPixel","noneFirstWidth","index","flexWidth","Math","floor","max","state","resizeState","fixedColumns","rightFixedColumns","addObserver","observer","removeObserver","indexOf","splice","event","onColumnsChange","onScrollableChange"],"sources":["../../../../../../packages/components/table/src/table-layout.ts"],"sourcesContent":["import { isRef, nextTick, ref } from 'vue'\nimport { isClient } from '@vueuse/core'\nimport { hasOwn } from '@element-plus/utils'\nimport { parseHeight } from './util'\nimport type { Ref } from 'vue'\n\nimport type { TableColumnCtx } from './table-column/defaults'\nimport type { TableHeader } from './table-header'\nimport type { Table } from './table/defaults'\nimport type { Store } from './store'\nclass TableLayout<T> {\n  observers: TableHeader[]\n  table: Table<T>\n  store: Store<T>\n  columns: TableColumnCtx<T>[]\n  fit: boolean\n  showHeader: boolean\n\n  height: Ref<null | number>\n  scrollX: Ref<boolean>\n  scrollY: Ref<boolean>\n  bodyWidth: Ref<null | number>\n  fixedWidth: Ref<null | number>\n  rightFixedWidth: Ref<null | number>\n  tableHeight: Ref<null | number>\n  headerHeight: Ref<null | number> // Table Header Height\n  appendHeight: Ref<null | number> // Append Slot Height\n  footerHeight: Ref<null | number> // Table Footer Height\n  viewportHeight: Ref<null | number> // Table Height - Scroll Bar Height\n  bodyHeight: Ref<null | number> // Table Height - Table Header Height\n  bodyScrollHeight: Ref<number>\n  fixedBodyHeight: Ref<null | number> // Table Height - Table Header Height - Scroll Bar Height\n  gutterWidth: number\n  constructor(options: Record<string, any>) {\n    this.observers = []\n    this.table = null\n    this.store = null\n    this.columns = []\n    this.fit = true\n    this.showHeader = true\n    this.height = ref(null)\n    this.scrollX = ref(false)\n    this.scrollY = ref(false)\n    this.bodyWidth = ref(null)\n    this.fixedWidth = ref(null)\n    this.rightFixedWidth = ref(null)\n    this.tableHeight = ref(null)\n    this.headerHeight = ref(44)\n    this.appendHeight = ref(0)\n    this.footerHeight = ref(44)\n    this.viewportHeight = ref(null)\n    this.bodyHeight = ref(null)\n    this.bodyScrollHeight = ref(0)\n    this.fixedBodyHeight = ref(null)\n    this.gutterWidth = 0\n    for (const name in options) {\n      if (hasOwn(options, name)) {\n        if (isRef(this[name])) {\n          this[name as string].value = options[name]\n        } else {\n          this[name as string] = options[name]\n        }\n      }\n    }\n    if (!this.table) {\n      throw new Error('Table is required for Table Layout')\n    }\n    if (!this.store) {\n      throw new Error('Store is required for Table Layout')\n    }\n  }\n\n  updateScrollY() {\n    const height = this.height.value\n    /**\n     * When the height is not initialized, it is null.\n     * After the table is initialized, when the height is not configured, the height is 0.\n     */\n    if (height === null) return false\n    const bodyWrapper = this.table.refs.bodyWrapper as HTMLElement\n    if (this.table.vnode.el && bodyWrapper) {\n      let scrollY = true\n      const prevScrollY = this.scrollY.value\n      /**\n       * When bodyHeight has no value,\n       * it means that the table height is not set,\n       * and the scroll bar will never appear\n       */\n      if (this.bodyHeight.value === null) {\n        scrollY = false\n      } else {\n        scrollY = bodyWrapper.scrollHeight > this.bodyHeight.value\n      }\n      this.scrollY.value = scrollY\n      return prevScrollY !== scrollY\n    }\n    return false\n  }\n\n  setHeight(value: string | number, prop = 'height') {\n    if (!isClient) return\n    const el = this.table.vnode.el\n    value = parseHeight(value)\n    this.height.value = Number(value)\n\n    if (!el && (value || value === 0))\n      return nextTick(() => this.setHeight(value, prop))\n\n    if (typeof value === 'number') {\n      el.style[prop] = `${value}px`\n      this.updateElsHeight()\n    } else if (typeof value === 'string') {\n      el.style[prop] = value\n      this.updateElsHeight()\n    }\n  }\n\n  setMaxHeight(value: string | number) {\n    this.setHeight(value, 'max-height')\n  }\n\n  getFlattenColumns(): TableColumnCtx<T>[] {\n    const flattenColumns = []\n    const columns = this.table.store.states.columns.value\n    columns.forEach((column) => {\n      if (column.isColumnGroup) {\n        // eslint-disable-next-line prefer-spread\n        flattenColumns.push.apply(flattenColumns, column.columns)\n      } else {\n        flattenColumns.push(column)\n      }\n    })\n\n    return flattenColumns\n  }\n\n  updateElsHeight() {\n    if (!this.table.$ready) return nextTick(() => this.updateElsHeight())\n    const {\n      tableWrapper,\n      headerWrapper,\n      appendWrapper,\n      footerWrapper,\n      tableHeader,\n      tableBody,\n    } = this.table.refs\n    if (tableWrapper && tableWrapper.style.display === 'none') {\n      // avoid v-show\n      return\n    }\n    const { tableLayout } = this.table.props\n    this.appendHeight.value = appendWrapper ? appendWrapper.offsetHeight : 0\n    if (this.showHeader && !headerWrapper && tableLayout === 'fixed') {\n      return\n    }\n    const headerTrElm: HTMLElement = tableHeader ? tableHeader : null\n    const noneHeader = this.headerDisplayNone(headerTrElm)\n    const headerWrapperOffsetHeight = headerWrapper?.offsetHeight || 0\n    const headerHeight = (this.headerHeight.value = !this.showHeader\n      ? 0\n      : headerWrapperOffsetHeight)\n    if (\n      this.showHeader &&\n      !noneHeader &&\n      headerWrapperOffsetHeight > 0 &&\n      (this.table.store.states.columns.value || []).length > 0 &&\n      headerHeight < 2\n    ) {\n      return nextTick(() => this.updateElsHeight())\n    }\n    const tableHeight = (this.tableHeight.value =\n      this.table?.vnode.el?.clientHeight)\n    const footerHeight = (this.footerHeight.value = footerWrapper\n      ? footerWrapper.offsetHeight\n      : 0)\n    if (this.height.value !== null) {\n      if (this.bodyHeight.value === null) {\n        requestAnimationFrame(() => this.updateElsHeight())\n      }\n      this.bodyHeight.value =\n        tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0)\n      this.bodyScrollHeight.value = tableBody?.scrollHeight\n    }\n    this.fixedBodyHeight.value = this.scrollX.value\n      ? this.bodyHeight.value - this.gutterWidth\n      : this.bodyHeight.value\n\n    this.viewportHeight.value = this.scrollX.value\n      ? tableHeight - this.gutterWidth\n      : tableHeight\n\n    this.updateScrollY()\n    this.notifyObservers('scrollable')\n  }\n\n  headerDisplayNone(elm: HTMLElement) {\n    if (!elm) return true\n    let headerChild = elm\n    while (headerChild.tagName !== 'DIV') {\n      if (getComputedStyle(headerChild).display === 'none') {\n        return true\n      }\n      headerChild = headerChild.parentElement\n    }\n    return false\n  }\n\n  updateColumnsWidth() {\n    if (!isClient) return\n    const fit = this.fit\n    const bodyWidth = this.table.vnode.el.clientWidth\n    let bodyMinWidth = 0\n\n    const flattenColumns = this.getFlattenColumns()\n    const flexColumns = flattenColumns.filter(\n      (column) => typeof column.width !== 'number'\n    )\n    flattenColumns.forEach((column) => {\n      // Clean those columns whose width changed from flex to unflex\n      if (typeof column.width === 'number' && column.realWidth)\n        column.realWidth = null\n    })\n    if (flexColumns.length > 0 && fit) {\n      flattenColumns.forEach((column) => {\n        bodyMinWidth += Number(column.width || column.minWidth || 80)\n      })\n      if (bodyMinWidth <= bodyWidth) {\n        // DON'T HAVE SCROLL BAR\n        this.scrollX.value = false\n\n        const totalFlexWidth = bodyWidth - bodyMinWidth\n\n        if (flexColumns.length === 1) {\n          flexColumns[0].realWidth =\n            Number(flexColumns[0].minWidth || 80) + totalFlexWidth\n        } else {\n          const allColumnsWidth = flexColumns.reduce(\n            (prev, column) => prev + Number(column.minWidth || 80),\n            0\n          )\n          const flexWidthPerPixel = totalFlexWidth / allColumnsWidth\n          let noneFirstWidth = 0\n\n          flexColumns.forEach((column, index) => {\n            if (index === 0) return\n            const flexWidth = Math.floor(\n              Number(column.minWidth || 80) * flexWidthPerPixel\n            )\n            noneFirstWidth += flexWidth\n            column.realWidth = Number(column.minWidth || 80) + flexWidth\n          })\n\n          flexColumns[0].realWidth =\n            Number(flexColumns[0].minWidth || 80) +\n            totalFlexWidth -\n            noneFirstWidth\n        }\n      } else {\n        // HAVE HORIZONTAL SCROLL BAR\n        this.scrollX.value = true\n        flexColumns.forEach((column) => {\n          column.realWidth = Number(column.minWidth)\n        })\n      }\n\n      this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth)\n      this.table.state.resizeState.value.width = this.bodyWidth.value\n    } else {\n      flattenColumns.forEach((column) => {\n        if (!column.width && !column.minWidth) {\n          column.realWidth = 80\n        } else {\n          column.realWidth = Number(column.width || column.minWidth)\n        }\n        bodyMinWidth += column.realWidth\n      })\n      this.scrollX.value = bodyMinWidth > bodyWidth\n\n      this.bodyWidth.value = bodyMinWidth\n    }\n\n    const fixedColumns = this.store.states.fixedColumns.value\n\n    if (fixedColumns.length > 0) {\n      let fixedWidth = 0\n      fixedColumns.forEach((column) => {\n        fixedWidth += Number(column.realWidth || column.width)\n      })\n\n      this.fixedWidth.value = fixedWidth\n    }\n\n    const rightFixedColumns = this.store.states.rightFixedColumns.value\n    if (rightFixedColumns.length > 0) {\n      let rightFixedWidth = 0\n      rightFixedColumns.forEach((column) => {\n        rightFixedWidth += Number(column.realWidth || column.width)\n      })\n\n      this.rightFixedWidth.value = rightFixedWidth\n    }\n    this.notifyObservers('columns')\n  }\n\n  addObserver(observer: TableHeader) {\n    this.observers.push(observer)\n  }\n\n  removeObserver(observer: TableHeader) {\n    const index = this.observers.indexOf(observer)\n    if (index !== -1) {\n      this.observers.splice(index, 1)\n    }\n  }\n\n  notifyObservers(event: string) {\n    const observers = this.observers\n    observers.forEach((observer) => {\n      switch (event) {\n        case 'columns':\n          observer.state?.onColumnsChange(this)\n          break\n        case 'scrollable':\n          observer.state?.onScrollableChange(this)\n          break\n        default:\n          throw new Error(`Table Layout don't have event ${event}.`)\n      }\n    })\n  }\n}\n\nexport default TableLayout\n"]},"metadata":{},"sourceType":"module"}