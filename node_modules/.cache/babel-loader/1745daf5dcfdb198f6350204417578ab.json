{"ast":null,"code":"import { defineComponent, ref, provide, unref, onMounted, nextTick, watch, onBeforeUnmount, renderSlot } from 'vue';\nimport '../../../constants/index2.mjs';\nimport { getEdges, tryFocus, focusableStack, focusFirstDescendant, obtainAllFocusableElements } from './utils2.mjs';\nimport { ON_MOUNT_FOCUS_EVT, ON_UNMOUNT_FOCUS_EVT, FOCUS_TRAP_INJECTION_KEY, FOCUS_ON_MOUNT, FOCUS_ON_MOUNT_OPTS, FOCUS_ON_UNMOUNT } from './tokens2.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { EVENT_CODE } from '../../../constants/aria2.mjs';\nconst _sfc_main = defineComponent({\n  name: \"ElFocusTrap\",\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean\n  },\n  emits: [ON_MOUNT_FOCUS_EVT, ON_UNMOUNT_FOCUS_EVT],\n  setup(props, {\n    emit\n  }) {\n    const focusTrapRef = ref();\n    const forwardRef = ref(null);\n    let lastFocusBeforeMounted;\n    let lastFocusAfterMounted;\n    const focusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true;\n      },\n      resume() {\n        this.paused = false;\n      }\n    };\n    const onKeydown = e => {\n      if (!props.loop && !props.trapped) return;\n      if (focusLayer.paused) return;\n      const {\n        key,\n        altKey,\n        ctrlKey,\n        metaKey,\n        currentTarget,\n        shiftKey\n      } = e;\n      const {\n        loop\n      } = props;\n      const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;\n      const currentFocusingEl = document.activeElement;\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget;\n        const [first, last] = getEdges(container);\n        const isTabbable = first && last;\n        if (!isTabbable) {\n          if (currentFocusingEl === container) e.preventDefault();\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            e.preventDefault();\n            if (loop) tryFocus(first, true);\n          } else if (shiftKey && currentFocusingEl === first) {\n            e.preventDefault();\n            if (loop) tryFocus(last, true);\n          }\n        }\n      }\n    };\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown\n    });\n    const focusOnMount = e => {\n      emit(ON_MOUNT_FOCUS_EVT, e);\n    };\n    const focusOnUnmount = e => emit(ON_UNMOUNT_FOCUS_EVT, e);\n    const onFocusIn = e => {\n      const trapContainer = unref(forwardRef);\n      if (focusLayer.paused || !trapContainer) return;\n      const target = e.target;\n      if (target && trapContainer.contains(target)) {\n        lastFocusAfterMounted = target;\n      } else {\n        tryFocus(lastFocusAfterMounted, true);\n      }\n    };\n    const onFocusOut = e => {\n      const trapContainer = unref(forwardRef);\n      if (focusLayer.paused || !trapContainer) return;\n      if (!trapContainer.contains(e.relatedTarget)) {\n        tryFocus(lastFocusAfterMounted, true);\n      }\n    };\n    const cleanupDocumentListeners = () => {\n      document.removeEventListener(\"focusin\", onFocusIn);\n      document.removeEventListener(\"focusout\", onFocusOut);\n    };\n    onMounted(() => {\n      const trapContainer = unref(forwardRef);\n      if (trapContainer) {\n        focusableStack.push(focusLayer);\n        const prevFocusedElement = document.activeElement;\n        lastFocusBeforeMounted = prevFocusedElement;\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement);\n        if (!isPrevFocusContained) {\n          const mountEvent = new Event(FOCUS_ON_MOUNT, FOCUS_ON_MOUNT_OPTS);\n          trapContainer.addEventListener(FOCUS_ON_MOUNT, focusOnMount);\n          trapContainer.dispatchEvent(mountEvent);\n          if (!mountEvent.defaultPrevented) {\n            nextTick(() => {\n              focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);\n              if (document.activeElement === prevFocusedElement) {\n                tryFocus(trapContainer);\n              }\n            });\n          }\n        }\n      }\n      watch(() => props.trapped, trapped => {\n        if (trapped) {\n          document.addEventListener(\"focusin\", onFocusIn);\n          document.addEventListener(\"focusout\", onFocusOut);\n        } else {\n          cleanupDocumentListeners();\n        }\n      }, {\n        immediate: true\n      });\n    });\n    onBeforeUnmount(() => {\n      cleanupDocumentListeners();\n      const trapContainer = unref(forwardRef);\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_ON_MOUNT, focusOnMount);\n        const unmountEvent = new Event(FOCUS_ON_UNMOUNT, FOCUS_ON_MOUNT_OPTS);\n        trapContainer.addEventListener(FOCUS_ON_UNMOUNT, focusOnUnmount);\n        trapContainer.dispatchEvent(unmountEvent);\n        if (!unmountEvent.defaultPrevented) {\n          tryFocus(lastFocusBeforeMounted != null ? lastFocusBeforeMounted : document.body, true);\n        }\n        trapContainer.removeEventListener(FOCUS_ON_UNMOUNT, focusOnMount);\n        focusableStack.remove(focusLayer);\n      }\n    });\n    return {\n      focusTrapRef,\n      forwardRef,\n      onKeydown\n    };\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return renderSlot(_ctx.$slots, \"default\");\n}\nvar ElFocusTrap = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue\"]]);\nexport { ElFocusTrap as default };","map":{"version":3,"mappings":"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","names":["_sfc_main","defineComponent","name","inheritAttrs","props","loop","trapped","emits","ON_MOUNT_FOCUS_EVT","ON_UNMOUNT_FOCUS_EVT","setup","emit","focusTrapRef","ref","focusLayer","paused","pause","resume","e","key","altKey","ctrlKey","metaKey","currentTarget","shiftKey","EVENT_CODE","currentFocusingEl","document","isTabbing","container","first","last","isTabbable","preventDefault","tryFocus","provide","FOCUS_TRAP_INJECTION_KEY","onKeydown","focusOnUnmount","unref","forwardRef","trapContainer","target","contains","lastFocusAfterMounted","relatedTarget","cleanupDocumentListeners","onFocusIn","onFocusOut","onMounted","focusableStack","push","prevFocusedElement","lastFocusBeforeMounted","isPrevFocusContained","mountEvent","Event","FOCUS_ON_MOUNT_OPTS","FOCUS_ON_MOUNT","focusOnMount","dispatchEvent","defaultPrevented","nextTick","focusFirstDescendant","activeElement","watch","immediate","onBeforeUnmount","unmountEvent","FOCUS_ON_UNMOUNT","remove","_renderSlot"],"sources":["../../../../../../packages/components/focus-trap/src/focus-trap.vue"],"sourcesContent":["<template>\n  <slot />\n</template>\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  ref,\n  unref,\n  watch,\n} from 'vue'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport {\n  focusFirstDescendant,\n  focusableStack,\n  getEdges,\n  obtainAllFocusableElements,\n  tryFocus,\n} from './utils'\nimport {\n  FOCUS_ON_MOUNT,\n  FOCUS_ON_MOUNT_OPTS,\n  FOCUS_ON_UNMOUNT,\n  FOCUS_TRAP_INJECTION_KEY,\n  ON_MOUNT_FOCUS_EVT,\n  ON_UNMOUNT_FOCUS_EVT,\n} from './tokens'\n\nimport type { FocusLayer } from './utils'\n\nexport default defineComponent({\n  name: 'ElFocusTrap',\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n  },\n  emits: [ON_MOUNT_FOCUS_EVT, ON_UNMOUNT_FOCUS_EVT],\n  setup(props, { emit }) {\n    const focusTrapRef = ref<HTMLElement | null>()\n    const forwardRef = ref<HTMLElement | null>(null)\n    let lastFocusBeforeMounted: HTMLElement | null\n    let lastFocusAfterMounted: HTMLElement | null\n\n    const focusLayer: FocusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true\n      },\n      resume() {\n        this.paused = false\n      },\n    }\n\n    const onKeydown = (e: KeyboardEvent) => {\n      if (!props.loop && !props.trapped) return\n      if (focusLayer.paused) return\n\n      const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e\n      const { loop } = props\n      const isTabbing =\n        key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey\n\n      const currentFocusingEl = document.activeElement\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget as HTMLElement\n        const [first, last] = getEdges(container)\n        const isTabbable = first && last\n\n        if (!isTabbable) {\n          if (currentFocusingEl === container) e.preventDefault()\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            e.preventDefault()\n            if (loop) tryFocus(first, true)\n          } else if (shiftKey && currentFocusingEl === first) {\n            e.preventDefault()\n            if (loop) tryFocus(last, true)\n          }\n        }\n      }\n    }\n\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown,\n    })\n\n    const focusOnMount = (e: Event) => {\n      emit(ON_MOUNT_FOCUS_EVT, e)\n    }\n    const focusOnUnmount = (e: Event) => emit(ON_UNMOUNT_FOCUS_EVT, e)\n    const onFocusIn = (e: Event) => {\n      const trapContainer = unref(forwardRef)\n      if (focusLayer.paused || !trapContainer) return\n      const target = e.target as HTMLElement | null\n      if (target && trapContainer.contains(target)) {\n        lastFocusAfterMounted = target\n      } else {\n        tryFocus(lastFocusAfterMounted, true)\n      }\n    }\n\n    const onFocusOut = (e: Event) => {\n      const trapContainer = unref(forwardRef)\n      if (focusLayer.paused || !trapContainer) return\n\n      if (\n        !trapContainer.contains(\n          (e as FocusEvent).relatedTarget as HTMLElement | null\n        )\n      ) {\n        tryFocus(lastFocusAfterMounted, true)\n      }\n    }\n\n    const cleanupDocumentListeners = () => {\n      document.removeEventListener('focusin', onFocusIn)\n      document.removeEventListener('focusout', onFocusOut)\n    }\n\n    onMounted(() => {\n      const trapContainer = unref(forwardRef)\n      if (trapContainer) {\n        focusableStack.push(focusLayer)\n        const prevFocusedElement = document.activeElement\n        lastFocusBeforeMounted = prevFocusedElement as HTMLElement | null\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement)\n        if (!isPrevFocusContained) {\n          const mountEvent = new Event(FOCUS_ON_MOUNT, FOCUS_ON_MOUNT_OPTS)\n          trapContainer.addEventListener(FOCUS_ON_MOUNT, focusOnMount)\n          trapContainer.dispatchEvent(mountEvent)\n          if (!mountEvent.defaultPrevented) {\n            nextTick(() => {\n              focusFirstDescendant(\n                obtainAllFocusableElements(trapContainer),\n                true\n              )\n              if (document.activeElement === prevFocusedElement) {\n                tryFocus(trapContainer)\n              }\n            })\n          }\n        }\n      }\n\n      watch(\n        () => props.trapped,\n        (trapped) => {\n          if (trapped) {\n            document.addEventListener('focusin', onFocusIn)\n            document.addEventListener('focusout', onFocusOut)\n          } else {\n            cleanupDocumentListeners()\n          }\n        },\n        { immediate: true }\n      )\n    })\n\n    onBeforeUnmount(() => {\n      cleanupDocumentListeners()\n      const trapContainer = unref(forwardRef)\n\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_ON_MOUNT, focusOnMount)\n        const unmountEvent = new Event(FOCUS_ON_UNMOUNT, FOCUS_ON_MOUNT_OPTS)\n\n        trapContainer.addEventListener(FOCUS_ON_UNMOUNT, focusOnUnmount)\n        trapContainer.dispatchEvent(unmountEvent)\n\n        if (!unmountEvent.defaultPrevented) {\n          tryFocus(lastFocusBeforeMounted ?? document.body, true)\n        }\n\n        trapContainer.removeEventListener(FOCUS_ON_UNMOUNT, focusOnMount)\n        focusableStack.remove(focusLayer)\n      }\n    })\n\n    return {\n      focusTrapRef,\n      forwardRef,\n      onKeydown,\n    }\n  },\n})\n</script>\n"]},"metadata":{},"sourceType":"module"}